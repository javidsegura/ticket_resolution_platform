- name: Docker compose launch with progressive rollout
  hosts: web_servers
  become: yes

  vars:
    target_user: "{{ ansible_user_id }}"
    remote_project_path: "/opt/{{ project_name }}"
    project_name: "ai-ticket-platform"
    stage_environment: "{{ lookup('env', 'ENVIRONMENT') | default('production', true) }}"
    src_backend_env_synced_path: "../../../backend/env_config/synced/.env.{{ stage_environment }}"
    dest_backend_env_synced_path: "{{ remote_project_path }}/backend/env_config/synced/.env.{{ stage_environment }}"
    backend_image_tag: "{{ stage_environment }}-{{ lookup('env', 'BACKEND_VERSION') | default('latest', true) }}"
    previous_tag_file: "{{ remote_project_path }}/.previous_backend_tag"
    health_check_retries: 3
    health_check_delay: 30

  tasks:
  - name: Show resolved paths
    debug:
      msg: "Source path is {{ src_backend_env_synced_path }} and destination path is {{ dest_backend_env_synced_path }}"

  - name: Show deployment tag
    debug:
      msg: "Deploying backend image tag: {{ backend_image_tag }}"

  - name: Ensure Docker and dependencies are installed (APT)
    ansible.builtin.apt:
      name:
        - docker.io
        - python3
        - python3-pip
        - curl
      state: present
      update_cache: yes
    when: ansible_pkg_mgr == "apt"

  - name: Ensure Docker and dependencies are installed (DNF)
    ansible.builtin.dnf:
      name:
        - docker
        - python3
        - python3-pip
        - curl
      state: present
      update_cache: yes
      allowerasing: yes
    when: ansible_pkg_mgr == "dnf"

  - name: Start Docker service
    ansible.builtin.service:
      name: docker
      state: started
      enabled: yes

  - name: Add ec2 user to the docker group
    ansible.builtin.user:
      name: "{{ target_user }}"
      groups: docker
      append: yes

  - name: Reset ssh connection in order to update user persmission
    ansible.builtin.meta: reset_connection

  - name: Create project directory
    ansible.builtin.file:
      path: "{{ remote_project_path }}"
      state: directory
      owner: "{{ target_user }}"
      group: docker
      mode: "0755"

  - name: Create frontend app directory
    ansible.builtin.file:
      path: "{{ remote_project_path }}/frontend/app"
      state: directory
      owner: "{{ target_user }}"
      group: docker
      mode: "0755"

  - name: Create backend directory
    ansible.builtin.file:
      path: "{{ remote_project_path }}/backend"
      state: directory
      owner: "{{ target_user }}"
      group: docker
      mode: "0755"

  - name: Create backend env_config directory structure
    ansible.builtin.file:
      path: "{{ remote_project_path }}/backend/env_config/synced"
      state: directory
      owner: "{{ target_user }}"
      group: docker
      mode: "0755"

  - name: Copy deployment directory structure
    ansible.builtin.copy:
      src: "../../../deployment/"
      dest: "{{ remote_project_path }}/deployment"
      owner: "{{ target_user }}"
      group: docker
      mode: "0644"
      directory_mode: "0755"

  - name: Copy backend synced .env
    ansible.builtin.copy:
      src: "{{ src_backend_env_synced_path  }}"
      dest: "{{ dest_backend_env_synced_path }}"
      owner: "{{ target_user }}"
      group: docker
      mode: "0644"
      directory_mode: "0755"

  - name: Copy frontend dist directory
    ansible.builtin.copy:
      src: "../../../frontend/app/dist/"
      dest: "{{ remote_project_path }}/frontend/app/dist/"
      owner: "{{ target_user }}"
      group: docker
      mode: "0644"
      directory_mode: "0755"

  - name: Create Docker CLI plugins directory
    ansible.builtin.file:
      path: /usr/local/lib/docker/cli-plugins
      state: directory
      mode: "0755"

  - name: Download Docker Compose V2 plugin
    ansible.builtin.get_url:
      url: "https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64"
      dest: "/usr/local/lib/docker/cli-plugins/docker-compose"
      mode: "0755"
      owner: root
      group: root

  - name: Install python docker library
    ansible.builtin.pip:
      name: docker
      state: present
      extra_args: "--user"
    become_user: "{{ target_user }}"

  # Read previous tag for potential rollback
  - name: Check if previous tag file exists
    ansible.builtin.stat:
      path: "{{ previous_tag_file }}"
    register: previous_tag_stat

  - name: Read previous backend tag
    ansible.builtin.slurp:
      src: "{{ previous_tag_file }}"
    register: previous_tag_content
    when: previous_tag_stat.stat.exists

  - name: Set previous tag variable
    set_fact:
      previous_backend_tag: "{{ previous_tag_content.content | b64decode | trim }}"
    when: previous_tag_stat.stat.exists

  - name: Show previous tag
    debug:
      msg: "Previous backend tag: {{ previous_backend_tag | default('none') }}"

  # Zero-downtime deployment using rolling update pattern
  # Step 1: Pull new image first (without recreating containers)
  - name: Pull new backend image
    ansible.builtin.shell: |
      cd {{ remote_project_path }}/deployment
      ENVIRONMENT={{ stage_environment }} \
      BACKEND_ENV_FILE={{ dest_backend_env_synced_path }} \
      SERVER_PUBLIC_IP={{ ansible_default_ipv4.address | default(ansible_host) }} \
      BACKEND_IMAGE_TAG={{ backend_image_tag }} \
      docker compose -p {{ project_name }} \
        -f docker-compose.yml \
        -f docker-compose.remote.yml \
        pull backend
    environment:
      ENVIRONMENT: "{{ stage_environment }}"
      BACKEND_ENV_FILE: "{{ dest_backend_env_synced_path }}"
      SERVER_PUBLIC_IP: "{{ ansible_default_ipv4.address | default(ansible_host) }}"
      BACKEND_IMAGE_TAG: "{{ backend_image_tag }}"
    become_user: "{{ target_user }}"

  # Step 2: Temporarily remove port mapping from docker-compose.remote.yml for scaling
  # We'll backup the original and create a version without ports
  - name: Backup original docker-compose.remote.yml
    ansible.builtin.copy:
      src: "{{ remote_project_path }}/deployment/docker-compose.remote.yml"
      dest: "{{ remote_project_path }}/deployment/docker-compose.remote.yml.backup"
      remote_src: yes
      owner: "{{ target_user }}"
      group: docker
      mode: "0644"

  - name: Remove port mapping from docker-compose.remote.yml for scaling
    ansible.builtin.shell: |
      cd {{ remote_project_path }}/deployment && \
      python3 << 'PYTHON_SCRIPT'
      import re
      
      with open('docker-compose.remote.yml', 'r') as f:
          content = f.read()
      
      # Remove the ports section (ports: and the following - "8000:8000" line)
      # Match: ports: followed by newline and indented port mapping
      pattern = r'^\s+ports:\s*\n\s+- "8000:8000"\s*\n'
      content = re.sub(pattern, '', content, flags=re.MULTILINE)
      
      with open('docker-compose.remote.yml', 'w') as f:
          f.write(content)
      PYTHON_SCRIPT
    become_user: "{{ target_user }}"

  # Step 3: Recreate existing container without port mapping (zero-downtime)
  - name: Recreate existing backend container without port mapping
    ansible.builtin.shell: |
      cd {{ remote_project_path }}/deployment
      ENVIRONMENT={{ stage_environment }} \
      BACKEND_ENV_FILE={{ dest_backend_env_synced_path }} \
      SERVER_PUBLIC_IP={{ ansible_default_ipv4.address | default(ansible_host) }} \
      BACKEND_IMAGE_TAG={{ previous_backend_tag | default(backend_image_tag) }} \
      docker compose -p {{ project_name }} \
        -f docker-compose.yml \
        -f docker-compose.remote.yml \
        up -d --force-recreate --no-deps backend
    environment:
      ENVIRONMENT: "{{ stage_environment }}"
      BACKEND_ENV_FILE: "{{ dest_backend_env_synced_path }}"
      SERVER_PUBLIC_IP: "{{ ansible_default_ipv4.address | default(ansible_host) }}"
      BACKEND_IMAGE_TAG: "{{ previous_backend_tag | default(backend_image_tag) }}"
    become_user: "{{ target_user }}"
    when: previous_tag_stat.stat.exists
    ignore_errors: yes

  # Step 4: Scale backend to 2 instances (old + new) - this starts new container with new image
  - name: Scale backend to 2 instances for zero-downtime deployment
    ansible.builtin.shell: |
      cd {{ remote_project_path }}/deployment
      ENVIRONMENT={{ stage_environment }} \
      BACKEND_ENV_FILE={{ dest_backend_env_synced_path }} \
      SERVER_PUBLIC_IP={{ ansible_default_ipv4.address | default(ansible_host) }} \
      BACKEND_IMAGE_TAG={{ backend_image_tag }} \
      docker compose -p {{ project_name }} \
        -f docker-compose.yml \
        -f docker-compose.remote.yml \
        up -d --scale backend=2 --no-deps backend
    environment:
      ENVIRONMENT: "{{ stage_environment }}"
      BACKEND_ENV_FILE: "{{ dest_backend_env_synced_path }}"
      SERVER_PUBLIC_IP: "{{ ansible_default_ipv4.address | default(ansible_host) }}"
      BACKEND_IMAGE_TAG: "{{ backend_image_tag }}"
    become_user: "{{ target_user }}"

  # Step 5: Wait for new backend instance to be healthy
  - name: Wait for new backend instance to be ready
    ansible.builtin.pause:
      seconds: 15
    register: wait_result

  - name: Wait for backend dependency health check (new instance via nginx)
    ansible.builtin.uri:
      url: "http://{{ ansible_default_ipv4.address | default(ansible_host) }}/api/health/dependencies"
      method: GET
      status_code: 200
    register: health_check
    retries: "{{ health_check_retries }}"
    delay: "{{ health_check_delay }}"
    until: health_check.status == 200
    ignore_errors: yes

  # Step 6: Identify and stop the old container explicitly (zero-downtime)
  # This ensures we stop the old container, not the new one
  - name: Get old backend container ID
    ansible.builtin.shell: |
      docker ps --filter "name={{ project_name }}-backend" --filter "ancestor=javidsegura/ai_ticket_platform:{{ previous_backend_tag | default('unknown') }}" --format "{{ '{{' }}.ID{{ '}}' }}" | head -n 1
    register: old_container_id
    when: previous_tag_stat.stat.exists
    become_user: "{{ target_user }}"
    changed_when: false

  - name: Stop old backend container explicitly
    ansible.builtin.shell: |
      docker stop {{ old_container_id.stdout }} || true
    when:
      - previous_tag_stat.stat.exists
      - old_container_id.stdout | length > 0
    become_user: "{{ target_user }}"
    ignore_errors: yes

  # Step 7: Scale down to 1 instance (should only have the new one now)
  # Remove the override file to restore port mapping
  # Step 7: Restore original docker-compose.remote.yml with port mapping
  - name: Restore original docker-compose.remote.yml
    ansible.builtin.copy:
      src: "{{ remote_project_path }}/deployment/docker-compose.remote.yml.backup"
      dest: "{{ remote_project_path }}/deployment/docker-compose.remote.yml"
      remote_src: yes
      owner: "{{ target_user }}"
      group: docker
      mode: "0644"

  - name: Remove backup file
    ansible.builtin.file:
      path: "{{ remote_project_path }}/deployment/docker-compose.remote.yml.backup"
      state: absent

  # Step 8: Scale down to 1 instance (should only have the new one now)
  # Note: We don't use the override file here, so port mapping is restored
  - name: Scale backend down to 1 instance (cleanup)
    ansible.builtin.shell: |
      cd {{ remote_project_path }}/deployment
      ENVIRONMENT={{ stage_environment }} \
      BACKEND_ENV_FILE={{ dest_backend_env_synced_path }} \
      SERVER_PUBLIC_IP={{ ansible_default_ipv4.address | default(ansible_host) }} \
      BACKEND_IMAGE_TAG={{ backend_image_tag }} \
      docker compose -p {{ project_name }} \
        -f docker-compose.yml \
        -f docker-compose.remote.yml \
        up -d --scale backend=1
    environment:
      ENVIRONMENT: "{{ stage_environment }}"
      BACKEND_ENV_FILE: "{{ dest_backend_env_synced_path }}"
      SERVER_PUBLIC_IP: "{{ ansible_default_ipv4.address | default(ansible_host) }}"
      BACKEND_IMAGE_TAG: "{{ backend_image_tag }}"
    become_user: "{{ target_user }}"

  # Step 9: Final health check after scaling down (via nginx)
  - name: Final health check after zero-downtime deployment
    ansible.builtin.uri:
      url: "http://{{ ansible_default_ipv4.address | default(ansible_host) }}/api/health/dependencies"
      method: GET
      status_code: 200
    register: final_health_check
    retries: "{{ health_check_retries }}"
    delay: "{{ health_check_delay }}"
    until: final_health_check.status == 200
    ignore_errors: yes

  # Rollback if health check fails
  - name: Rollback to previous version if health check failed
    block:
      - name: Show rollback message
        debug:
          msg: "Health check failed! Rolling back to {{ previous_backend_tag }}"

      - name: Get ID of the failed backend container
        # Use grep to ensure we find the container even if it is 'Exited'
        shell: docker ps -a | grep "url-shortener-backend" | head -n 1 | awk '{print $1}'
        register: failed_backend_id
        ignore_errors: yes

      - name: Get Docker logs of failed backend
        shell: "docker logs {{ failed_backend_id.stdout }}"
        register: backend_failed_logs
        ignore_errors: yes
        # Only run this if we actually found an ID
        when: failed_backend_id.stdout | length > 0

      - name: Print failed backend logs
        debug:
          var: backend_failed_logs.stdout_lines
        when:
          - backend_failed_logs.skipped is not defined
          - backend_failed_logs.stdout_lines is defined

      - name: Deploy previous backend version
        community.docker.docker_compose_v2:
          project_src: "{{ remote_project_path }}/deployment"
          files:
            - docker-compose.yml
            - docker-compose.{{stage_environment}}.yml
          project_name: "{{ project_name }}"
          state: present
          pull: always
          recreate: always
        environment:
          ENVIRONMENT: "{{ stage_environment }}"
          BACKEND_ENV_FILE: "{{ dest_backend_env_synced_path }}"
          SERVER_PUBLIC_IP: "{{ ansible_default_ipv4.address | default(ansible_host) }}"
          BACKEND_IMAGE_TAG: "{{ previous_backend_tag }}"

      - name: Fail deployment
        fail:
          msg: "Deployment failed - rolled back to {{ previous_backend_tag }}"
    when:
      - health_check.failed
      - previous_tag_stat.stat.exists

  - name: Fail if no previous version to rollback to
    fail:
      msg: "Health check failed and no previous version exists to rollback to"
    when:
      - health_check.failed
      - not previous_tag_stat.stat.exists

  # Save current tag as previous for next deployment
  - name: Save current backend tag for future rollbacks
    ansible.builtin.copy:
      content: "{{ backend_image_tag }}"
      dest: "{{ previous_tag_file }}"
      owner: "{{ target_user }}"
      group: docker
      mode: "0644"
    when: not health_check.failed

  - name: Deployment successful
    debug:
      msg: "Backend {{ backend_image_tag }} deployed successfully!"
    when: not health_check.failed
